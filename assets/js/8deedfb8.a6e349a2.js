"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[556],{26437:function(e,i,n){n.r(i),n.d(i,{frontMatter:function(){return d},contentTitle:function(){return o},metadata:function(){return s},toc:function(){return m},default:function(){return c}});var l=n(87462),a=n(63366),t=(n(67294),n(3905)),r=["components"],d={},o="Changelog",s={type:"mdx",permalink:"/roblox-lua-promise/CHANGELOG",source:"@site/pages/CHANGELOG.md"},m=[{value:"4.0.0",id:"400",children:[{value:"Changed",id:"changed",children:[],level:3}],level:2},{value:"4.0.0-rc.3",id:"400-rc3",children:[{value:"Fixed",id:"fixed",children:[],level:3}],level:2},{value:"4.0.0-rc.2 - 2022-01-02",id:"400-rc2---2022-01-02",children:[{value:"Fixed",id:"fixed-1",children:[],level:3}],level:2},{value:"3.2.1 - 2022-01-02",id:"321---2022-01-02",children:[{value:"Fixed",id:"fixed-2",children:[],level:3}],level:2},{value:"4.0.0-rc.1 - 2021-12-28",id:"400-rc1---2021-12-28",children:[{value:"Changed",id:"changed-1",children:[],level:3},{value:"Removed",id:"removed",children:[],level:3}],level:2},{value:"3.2.0 - 2021-12-27",id:"320---2021-12-27",children:[{value:"Added",id:"added",children:[],level:3},{value:"Changed",id:"changed-2",children:[],level:3}],level:2},{value:"3.1.0 - 2020-12-01",id:"310---2020-12-01",children:[{value:"Added",id:"added-1",children:[],level:3}],level:2},{value:"3.0.1 - 2020-08-24",id:"301---2020-08-24",children:[{value:"Fixed",id:"fixed-3",children:[],level:3}],level:2},{value:"3.0.0 - 2020-08-17",id:"300---2020-08-17",children:[{value:"Changed",id:"changed-3",children:[],level:3}],level:2},{value:"3.0.0-rc.3 - 2020-07-10",id:"300-rc3---2020-07-10",children:[{value:"Fixed",id:"fixed-4",children:[],level:3}],level:2},{value:"3.0.0-rc.1 - 2020-06-02",id:"300-rc1---2020-06-02",children:[{value:"Changed",id:"changed-4",children:[],level:3},{value:"Added",id:"added-2",children:[],level:3},{value:"Fixed",id:"fixed-5",children:[],level:3}],level:2},{value:"2.5.1",id:"251",children:[],level:2},{value:"2.5.0",id:"250",children:[],level:2},{value:"2.4.0",id:"240",children:[],level:2},{value:"2.3.1",id:"231",children:[],level:2},{value:"2.3.0",id:"230",children:[],level:2},{value:"2.2.0",id:"220",children:[],level:2},{value:"2.1.0",id:"210",children:[],level:2},{value:"2.0.0",id:"200",children:[],level:2}],u={toc:m};function c(e){var i=e.components,n=(0,a.Z)(e,r);return(0,t.kt)("wrapper",(0,l.Z)({},u,n,{components:i,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"changelog"},"Changelog"),(0,t.kt)("h2",{id:"400"},"[4.0.0]"),(0,t.kt)("h3",{id:"changed"},"Changed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise:finally")," no longer observes a rejection from a Promise. Calling ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise:finally")," is mostly transparent now.",(0,t.kt)("ul",{parentName:"li"},(0,t.kt)("li",{parentName:"ul"},"The Promise returned by ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise:finally")," resolves or rejects with whatever the parent Promise resolved or rejected with. It will be cancelled if the parent Promise is cancelled."),(0,t.kt)("li",{parentName:"ul"},"The value returned from the ",(0,t.kt)("inlineCode",{parentName:"li"},"finally")," handler is discarded now."),(0,t.kt)("li",{parentName:"ul"},"If the value returned from the ",(0,t.kt)("inlineCode",{parentName:"li"},"finally")," handler is a Promise, we wait for it to resolve, but we do not use its value."),(0,t.kt)("li",{parentName:"ul"},"If the value returned from the ",(0,t.kt)("inlineCode",{parentName:"li"},"finally")," handler is a Promise and it rejects, ",(0,t.kt)("inlineCode",{parentName:"li"},"finally")," returns the new rejected value."))),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise:finally")," no longer counts as a consumer of the parent Promise for cancellation purposes. If all consumers are cancelled and the only remaining callbacks are finally handlers, the Promise is now cancelled."),(0,t.kt)("li",{parentName:"ul"},"The Promise executor thread is now closed with ",(0,t.kt)("inlineCode",{parentName:"li"},"coroutine.close")," when the Promise is cancelled."),(0,t.kt)("li",{parentName:"ul"},"The Promise executor thread is now closed after the Promise settles (calling ",(0,t.kt)("inlineCode",{parentName:"li"},"resolve")," or ",(0,t.kt)("inlineCode",{parentName:"li"},"reject"),")."),(0,t.kt)("li",{parentName:"ul"},"Callbacks enqueued with ",(0,t.kt)("inlineCode",{parentName:"li"},"andThen")," and ",(0,t.kt)("inlineCode",{parentName:"li"},"catch")," are now dequeued if the Promise returned by ",(0,t.kt)("inlineCode",{parentName:"li"},"andThen"),"/",(0,t.kt)("inlineCode",{parentName:"li"},"catch")," is cancelled."),(0,t.kt)("li",{parentName:"ul"},"Calling ",(0,t.kt)("inlineCode",{parentName:"li"},"andThen")," or ",(0,t.kt)("inlineCode",{parentName:"li"},"catch")," on an already-cancelled Promise now returns a cancelled Promise instead of returning a rejected Promise"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},":await"),", ",(0,t.kt)("inlineCode",{parentName:"li"},":expect"),", and ",(0,t.kt)("inlineCode",{parentName:"li"},":awaitStatus")," are no longer backed by BindableEvents, and now use the task library directly, so performance should be better.")),(0,t.kt)("h2",{id:"400-rc3"},"[4.0.0-rc.3]"),(0,t.kt)("h3",{id:"fixed"},"Fixed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Fix unhandled rejection warning appearing when using :awaitStatus")),(0,t.kt)("h2",{id:"400-rc2---2022-01-02"},"[4.0.0-rc.2]"," - 2022-01-02"),(0,t.kt)("h3",{id:"fixed-1"},"Fixed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Fix bug where Promise.fold does not return correct value if there is an unresolved Promise in the passed list (#77)")),(0,t.kt)("h2",{id:"321---2022-01-02"},"[3.2.1]"," - 2022-01-02"),(0,t.kt)("h3",{id:"fixed-2"},"Fixed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Fix bug where Promise.fold does not return correct value if there is an unresolved Promise in the passed list (#77)")),(0,t.kt)("h2",{id:"400-rc1---2021-12-28"},"[4.0.0-rc.1]"," - 2021-12-28"),(0,t.kt)("h3",{id:"changed-1"},"Changed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise:finally")," no longer observes a rejection from a Promise. Calling ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise:finally")," is mostly transparent now.",(0,t.kt)("ul",{parentName:"li"},(0,t.kt)("li",{parentName:"ul"},"The Promise returned by ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise:finally")," resolves or rejects with whatever the parent Promise resolved or rejected with. It will be cancelled if the parent Promise is cancelled."),(0,t.kt)("li",{parentName:"ul"},"The value returned from the ",(0,t.kt)("inlineCode",{parentName:"li"},"finally")," handler is discarded now."),(0,t.kt)("li",{parentName:"ul"},"If the value returned from the ",(0,t.kt)("inlineCode",{parentName:"li"},"finally")," handler is a Promise, we wait for it to resolve, but we do not use its value."),(0,t.kt)("li",{parentName:"ul"},"If the value returned from the ",(0,t.kt)("inlineCode",{parentName:"li"},"finally")," handler is a Promise and it rejects, ",(0,t.kt)("inlineCode",{parentName:"li"},"finally")," returns the new rejected value."))),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise:finally")," no longer counts as a consumer of the parent Promise for cancellation purposes. If all consumers are cancelled and the only remaining callbacks are finally handlers, the Promise is now cancelled."),(0,t.kt)("li",{parentName:"ul"},"The Promise executor thread is now closed with ",(0,t.kt)("inlineCode",{parentName:"li"},"coroutine.close")," when the Promise is cancelled."),(0,t.kt)("li",{parentName:"ul"},"The Promise executor thread is now closed after the Promise settles (calling ",(0,t.kt)("inlineCode",{parentName:"li"},"resolve")," or ",(0,t.kt)("inlineCode",{parentName:"li"},"reject"),")."),(0,t.kt)("li",{parentName:"ul"},"Callbacks enqueued with ",(0,t.kt)("inlineCode",{parentName:"li"},"andThen")," and ",(0,t.kt)("inlineCode",{parentName:"li"},"catch")," are now dequeued if the Promise returned by ",(0,t.kt)("inlineCode",{parentName:"li"},"andThen"),"/",(0,t.kt)("inlineCode",{parentName:"li"},"catch")," is cancelled."),(0,t.kt)("li",{parentName:"ul"},"Calling ",(0,t.kt)("inlineCode",{parentName:"li"},"andThen")," or ",(0,t.kt)("inlineCode",{parentName:"li"},"catch")," on an already-cancelled Promise now returns a cancelled Promise instead of returning a rejected Promise"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},":await"),", ",(0,t.kt)("inlineCode",{parentName:"li"},":expect"),", and ",(0,t.kt)("inlineCode",{parentName:"li"},":awaitStatus")," are no longer backed by BindableEvents, and now use the task library directly, so performance should be better.")),(0,t.kt)("h3",{id:"removed"},"Removed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise:done")," and its associated members have been removed.")),(0,t.kt)("h2",{id:"320---2021-12-27"},"[3.2.0]"," - 2021-12-27"),(0,t.kt)("h3",{id:"added"},"Added"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.onUnhandledRejection")," global event"),(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.retryWithDelay"))),(0,t.kt)("h3",{id:"changed-2"},"Changed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Callable tables are now allowed anywhere that a function are allowed (",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.new"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"andThen"),", etc)")),(0,t.kt)("h2",{id:"310---2020-12-01"},"[3.1.0]"," - 2020-12-01"),(0,t.kt)("h3",{id:"added-1"},"Added"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Added ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.fold")," (#47)")),(0,t.kt)("h2",{id:"301---2020-08-24"},"[3.0.1]"," - 2020-08-24"),(0,t.kt)("h3",{id:"fixed-3"},"Fixed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Make ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.is")," work with promises from old versions of the library (#41)"),(0,t.kt)("li",{parentName:"ul"},"Make ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.delay")," properly break out of the current loop (#40)"),(0,t.kt)("li",{parentName:"ul"},"Allow upvalues captured by queued callbacks to be garbage collected when the Promise resolves by deleting the queues when the Promise settles (#39)")),(0,t.kt)("h2",{id:"300---2020-08-17"},"[3.0.0]"," - 2020-08-17"),(0,t.kt)("h3",{id:"changed-3"},"Changed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise.delay")," now uses ",(0,t.kt)("inlineCode",{parentName:"li"},"os.clock")),(0,t.kt)("li",{parentName:"ul"},"Made ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.delay")," behavior more consistent when creating new timers in the callback of a timer.")),(0,t.kt)("h2",{id:"300-rc3---2020-07-10"},"[3.0.0-rc.3]"," - 2020-07-10"),(0,t.kt)("h3",{id:"fixed-4"},"Fixed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Fixed a bug where queued ",(0,t.kt)("inlineCode",{parentName:"li"},"andThen")," and ",(0,t.kt)("inlineCode",{parentName:"li"},"catch")," callbacks did not begin on their own new threads.")),(0,t.kt)("h2",{id:"300-rc1---2020-06-02"},"[3.0.0-rc.1]"," - 2020-06-02"),(0,t.kt)("h3",{id:"changed-4"},"Changed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Runtime errors are now represented by objects. You must call tostring on rejection values before assuming they are strings (this was always good practice, but is required now)."),(0,t.kt)("li",{parentName:"ul"},"Yielding is now allowed in ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.new"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"andThen"),", and ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.try")," executors."),(0,t.kt)("li",{parentName:"ul"},"Errors now have much better stack traces due to using ",(0,t.kt)("inlineCode",{parentName:"li"},"xpcall")," internally instead of ",(0,t.kt)("inlineCode",{parentName:"li"},"pcall"),"."),(0,t.kt)("li",{parentName:"ul"},"Stack traces will now be more direct and not include as many internal calls within the Promise library."),(0,t.kt)("li",{parentName:"ul"},"Chained promises from ",(0,t.kt)("inlineCode",{parentName:"li"},"resolve()")," or returning from andThen now have improved rejection messages for debugging."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise.async")," has been renamed to ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.defer")," (",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.async")," references same function for compatibility)"),(0,t.kt)("li",{parentName:"ul"},"Promises now have a ",(0,t.kt)("inlineCode",{parentName:"li"},"__tostring")," metamethod, which returns ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise(Resolved)")," or whatever the current status is."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise:timeout()")," now rejects with a ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.Error(Promise.Error.Kind.TimedOut)")," object. (Formerly rejected with the string ",(0,t.kt)("inlineCode",{parentName:"li"},'"Timed out"'),")"),(0,t.kt)("li",{parentName:"ul"},"Attaching a handler to a cancelled Promise now rejects with a ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.Error(Promise.Error.Kind.AlreadyCancelled)"),". (Formerly rejected with the string ",(0,t.kt)("inlineCode",{parentName:"li"},'"Promise is cancelled"'),")"),(0,t.kt)("li",{parentName:"ul"},"Let ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise:expect()")," throw rejection objects")),(0,t.kt)("h3",{id:"added-2"},"Added"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"New Promise Error class is exposed at ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.Error"),", which includes helpful static methods like ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.Error.is"),"."),(0,t.kt)("li",{parentName:"ul"},"Added ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise:now()")," (#23)"),(0,t.kt)("li",{parentName:"ul"},"Added ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.each")," (#21)"),(0,t.kt)("li",{parentName:"ul"},"Added ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.retry")," (#16)"),(0,t.kt)("li",{parentName:"ul"},"Added ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.fromEvent")," (#14)"),(0,t.kt)("li",{parentName:"ul"},"Improved test coverage for asynchronous and time-driven functions")),(0,t.kt)("h3",{id:"fixed-5"},"Fixed"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Changed ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.is")," to be safe when dealing with tables that have an ",(0,t.kt)("inlineCode",{parentName:"li"},"__index")," metamethod that creates an error."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise.delay")," resolve value (time passed) is now more accurate (previously passed time based on when we started resuming threads instead of the current time. This is a very minor difference.)")),(0,t.kt)("h2",{id:"251"},"[2.5.1]"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Fix issue with rejecting with non-string not propagating correctly.")),(0,t.kt)("h2",{id:"250"},"[2.5.0]"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Add Promise.tap"),(0,t.kt)("li",{parentName:"ul"},"Fix bug with C functions not working when passed to andThen"),(0,t.kt)("li",{parentName:"ul"},"Fix issue with Promise.race/all always cancelling instead of only cancelling if the Promise has no other consumers"),(0,t.kt)("li",{parentName:"ul"},"Make error checking more robust across many methods."),(0,t.kt)("li",{parentName:"ul"},"Promise.Status members are now strings instead of symbols, and indexing a non-existent value will error."),(0,t.kt)("li",{parentName:"ul"},"Improve stack traces"),(0,t.kt)("li",{parentName:"ul"},"Promise.promisify will now turn errors into rejections even if they occur after a yield."),(0,t.kt)("li",{parentName:"ul"},"Add Promise.try"),(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"done"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"doneCall"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"doneReturn")),(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"andThenReturn"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"finallyReturn")),(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.delay"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"promise:timeout")),(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.some"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.any")),(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.allSettled")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise.all")," and ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.race")," are now cancellable.")),(0,t.kt)("h2",{id:"240"},"[2.4.0]"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise.is"),' now only checks if the object is "andThennable" (has an ',(0,t.kt)("inlineCode",{parentName:"li"},"andThen")," method).")),(0,t.kt)("h2",{id:"231"},"[2.3.1]"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Make unhandled rejection warning trigger on next Heartbeat")),(0,t.kt)("h2",{id:"230"},"[2.3.0]"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Remove ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.spawn")," from the public API."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise.async")," still inherits the behavior from ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.spawn"),"."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise.async")," now wraps the callback in ",(0,t.kt)("inlineCode",{parentName:"li"},"pcall")," and rejects if an error occurred."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise.new")," has now has an explicit error message when attempting to yield inside of it.")),(0,t.kt)("h2",{id:"220"},"[2.2.0]"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"Promise.promisify")," now uses ",(0,t.kt)("inlineCode",{parentName:"li"},"coroutine.wrap")," instead of ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise.spawn"))),(0,t.kt)("h2",{id:"210"},"[2.1.0]"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"finallyCall"),", ",(0,t.kt)("inlineCode",{parentName:"li"},"andThenCall")),(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"awaitValue"))),(0,t.kt)("h2",{id:"200"},"[2.0.0]"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Add Promise.race"),(0,t.kt)("li",{parentName:"ul"},"Add Promise.async"),(0,t.kt)("li",{parentName:"ul"},"Add Promise.spawn"),(0,t.kt)("li",{parentName:"ul"},"Add Promise.promisify"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"finally")," now silences the unhandled rejection warning"),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"onCancel")," now returns if the Promise was cancelled at call time."),(0,t.kt)("li",{parentName:"ul"},"Cancellation now propagates downstream."),(0,t.kt)("li",{parentName:"ul"},"Add ",(0,t.kt)("inlineCode",{parentName:"li"},"Promise:awaitStatus")),(0,t.kt)("li",{parentName:"ul"},"Calling ",(0,t.kt)("inlineCode",{parentName:"li"},"resolve")," with a Promise while the resolving Promise is cancelled instantly cancels the passed Promise as an optimization."),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"finally")," now passes the Promise status as a parameter.")))}c.isMDXComponent=!0}}]);